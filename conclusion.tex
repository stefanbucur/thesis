Symbolic execution is an automated test generation technique that stands out for its soundness, completeness, and flexibility.
%
Alas, it faces significant hurdles on its way to adoption for the large systems encountered in the real world, because of path explosion and the excessive complexity of symbolic formulae.


Exploiting the system modularity and the natural boundaries between components is the most promising approach for handling large systems.
%
However, to effectively provide the environment interface of a system component, a symbolic execution engine has to find the right balance between efficiency, accuracy, and completeness---a conundrum known as the environment problem.


This thesis examines the trade-offs employed by existing symbolic execution engines and proposes new techniques to improve these trade-offs on one axis of the program environment design space: the stability of its interface.


\paragraph{Stable Operating System Interfaces}

On the one end of the axis, this thesis addresses the environment problem for system software interacting with the operating system, which has a stable and well-documented interface.

This thesis shows that it is economical to provide an accurate and practically complete model-based operating system environment, by splitting the model into a core set of primitives built into the symbolic execution engine, on top of which a full operating system interface is emulated inside the guest (Chapter~\ref{ch:cloud9}).
%
As few as two primitives are sufficient to support complex operating system interfaces: threads  with synchronization and address spaces with shared memory.
%
The operating system model engenders a more effective way for developers to test their software with the symbolic execution engine, by writing symbolic tests.  Symbolic tests control the operating system model to explore conditions that are hard to produce reliably in a concrete test case.

We prototyped the split model approach and symbolic tests in the \cnine symbolic execution platform, which exposes hard-to-reproduce bugs in systems such as UNIX utilities, web servers, and distributed systems.
%
\cnine is available at {\urlstyle{same}\url{http://cloud9.epfl.ch}}.


\paragraph{Fast-Changing Interpreted Languages}

On the other end of the axis, this thesis addresses the problem of building complete and correct symbolic execution engines for interpreted languages, such as Python, Ruby, or JavaScript.
%
The environment of an interpreted program consists of the language semantics and the library of functions built into the interpreter.
%
Building a symbolic execution engine by hand for a modern interpreted language is a significant engineering effort, due to their rich semantics, rapid evolution, and lack of precise specifications.

This thesis introduces the idea of using the language interpreter itself as an ``executable specification'' (Chapter~\ref{ch:chef}).
%
The idea is to run the interpreter executable inside a binary-level symbolic execution engine, while running the target program.  The resulting system acts as a high-level symbolic execution engine for the program.
%
To circumvent the path explosion arising in the interpreter, Class-Uniform Path Analysis (CUPA) groups the execution paths in the symbolic execution tree into equivalence classes that isloate the sources of path explosion in the interpreter.
%
We prototyped these ideas in the form of \chef, a symbolic execution platform for interpreted languages that generates up to 1000 times more tests in popular Python and Lua packages compared to a plain execution of the interpreters.
%
\chef is available at {\urlstyle{same}\url{http://dslab.epfl.ch/proj/chef/}}.


\paragraph{Towards an Automated Software Testing Service}

Together, the two techniques introduced in this thesis enable effective symbolic execution for a wide range of software, from low-level system utilities, to web servers and interpreted programs.
%
This software forms the modern web application stack, which consists of a high-level application logic written against a platform-as-a-service (PaaS) API, transparently scaled in the cloud across machines running the system software.

The work presented in this thesis enables the vision of an automated software testing service based on symbolic execution that targets applications running ``in-vivo'' in their production environments (Chapter~\ref{ch:paas}).
%
The testing service focuses on each application layer at a time, from the low-level web server to the high-level application logic, avoiding the combinatorial explosion of paths across layers.
%
The service scales to large clusters of commodity hardware owing to a symbolic execution parallelization algorithm that is the first to demonstrate linear scalability.

\paragraph{Looking Forward}

%% The lesson is that hand-written models outperform the ones inferred from the implementation, yet bridging the gap is crucial for automation.

%% Looking forward, we need to bridge the performance gap between hand-written engines and the ones obtained from interpreters:

%% Reduce redundancy in symbolic analysis (state merging, compositionality);

%% Replace implementations with abstractions evaluated lazily by dedicated decision procedures;

%% Automate the process of abstraction.  Intuitively, this is how a human developer parses a codebase to get an intuition of what's going on there.  We need to automate this.  This is a cross-disciplinary effort, spreading from program analysis into machine learning and artificial intelligence.


%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
