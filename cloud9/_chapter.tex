%% Symbolically executing real-world software is challenging not only because of path explosion but also because real-world systems interact with their environment in varied and complex ways. This section describes our experience building \cnine's symbolic model of a POSIX environment, which supports most essential interfaces: threads, process management, sockets, pipes, polling, etc. We believe the described techniques are general enough to model other OSes and environments as well.

Operating systems expose a complex stateful interface to user programs.
%
In this chapter, we introduce \cnine, a symbolic execution platform for system programs that is based on a symbolic model of most essential operating system abstractions, including threads, process management, sockets, pipes, and polling. (Section~\ref{sec:cloud9:primitives}).
%
We report on our experience modeling these abstractions for the standard POSIX interface (Section~\ref{sec:cloud9:posix}).
%
Our POSIX model includes extensions that developers can use in \emph{symbolic tests}.  The extensions control non-deterministic operating system events, such as thread scheduling and network flow control, to help increase coverage in the target programs (Section~\ref{sec:cloud9:symtests}).

\section{Symbolic Execution Engine Primitives for System Programs}
\label{sec:cloud9:primitives}
\input{cloud9/splitmodel}

\section{Case Study: A Symbolic POSIX Interface Model}
\label{sec:cloud9:posix}
\input{cloud9/posixmodel}

\section{Symbolic Test Suites}
\label{sec:cloud9:symtests}
\input{cloud9/symtests}

\section{Summary}

Operating systems expose a complex stateful interface to user programs.
%
In this chapter, we showed a way to provide an operating system environment for symbolic execution by employing a split operating system model.  A core set of primitives built into the symbolic execution engine serves as a base, on top of which a full operating system interface is emulated inside the guest.
%
As few as three primitives are sufficient to support complex operating system interfaces: threads and processes, synchronization, and address spaces with shared memory.
%
%% Additionally, these primitives can be implemented efficiently in a symbolic execution engine, by reusing existing symbolic execution components.
%
We showed how to use the core primitives to provide an accurate model of the POSIX interface.
%
Our POSIX model includes extensions that developers can use to control non-deterministic operating system events, such as thread scheduling and network flow control, in order to increase the coverage in the target programs.

%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
