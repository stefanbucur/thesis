In this section, we first present the design space of an operating system model (Section~\ref{sec:cloud9:modelspace}).  We then present our approach of a split model (Section~\ref{sec:cloud9:approach}) and how we leverage it using symbolic tests.


\subsection{The Design Space of Operating System Models}
\label{sec:cloud9:modelspace}

The goal of a symbolic model is to simulate the behavior of a real execution environment, while maintaining the necessary symbolic state behind the environment interface.
%
The symbolic execution engine (SEE) can then seamlessly transition back and forth between the program and the environment.

Writing and maintaining a model can be laborious and prone to error~\cite{s2eSystem}.
%
However, for operating system interfaces, which are typically stable and well documented, investing the time to model them becomes worthwile.

Ideally, a symbolic model would be implemented as code that gets executed by the symbolic execution engine (i.e., guest-level code), substituting the implementation of the operating system and the C library.
%
Such a model can be substantially faster.  For instance, in the Linux kernel, transferring a packet between two hosts exercises the entire TCP/IP networking stack and the associated driver code, amounting to over 30 \kloc.  In contrast, our \cnine's POSIX model achieves the same functionality in about 1.5 \kloc.  Requirements that complicate a real environment/OS implementation, such as performance and extensibility, can be ignored in a symbolic model.

However, not all operating system abstractions can be directly expressed as guest code.
%
In general, the problematic abstractions are those \emph{incompatible} with the execution model of the symbolic execution engine.
%
For example, providing support for multiple execution threads may not be achievable in the guest of a symbolic execution engine designed to run sequentially, unless the guest can manipulate the current stack and program counter.
%
There are other abstractions incompatible with the typical sequential single-process execution model of a symbolic execution engine, such as processes, synchronization, and shared memory.

A possible alternative is to implement the operating system model inside the symbolic execution engine, where we can define any abstraction.
%
However, this approach is undesirable.  A model built into a symbolic execution engine is significantly more expensive to produce, because the model code has to handle explicitly symbolic data and the program state.
%
For example, while a guest model of the \codebit{open} system call could directly use the file name string buffer, a built-in model needs to explictly invoke read operations for the string bytes, then extract the character values from the symbolic AST expressions.


\subsection{A Split Operating System Model}
\label{sec:cloud9:approach}

Our key idea is to take the best from both worlds and provide an operating system model that is \emph{split} between a set of built-in primitives and guest-level code.
%
The built-in primitives model only the minimal operating system abstractions that would be more expensive or impossible to model at the guest level.
%
In turn, the guest-level code implements a complete operating system interface on top of these primitives.
%
In analogy to the system calls exposed by an operating system to user programs, the symbolic execution engine provides its primitives to the guest through a set of ``symbolic system calls''.

The built-in primitives provide the operating system abstractions that depend on the execution model of the symbolic execution engine.
%
We identified two such abstractions that are prevalent in operating systems: \emph{multiple threads} and \emph{address spaces}.
%
We designed their support in the symbolic execution engine according to two goals: (1) minimizing the complexity of the guest code using them, and (2) capturing all possible behaviors in the real operating system, including corner-case, hard-to-reproduce scenarios.
%
The latter is especially relevant when using the symbolic execution engine to find bugs occurring in the program interaction with the operating system.

We next describe the two abstractions and their design in the symbolic execution engine.

\paragraph{Multithreading}

%% A symbolic execution engine is essentially an interpreter of program statements.
%% %
To provide support for multiple threads, the symbolic execution engine maintains in each execution state a set of per-thread stacks, holding the current program location, the execution call chain, and local variables.
%
During symbolic execution, the execution alternates between the threads, governed by a thread scheduler built into the symbolic execution engine.

To simplify synchronization inside the guest model, we use a cooperative scheduler.  An enabled thread runs uninterrupted (atomically), until either (a) the thread goes to sleep, (b) the thread is explicitly preempted, or (c) the thread is terminated via a symbolic system call.

The scheduler can be configured to schedule the next thread deterministically, or to fork the execution state for each possible next thread.
%
The latter case is useful when looking for concurrency bugs.  At the same time, it can be a significant source of path explosion, so it can be selectively disabled when not needed.

The symbolic execution engine can detect hangs in the system, such as deadlocks, when a thread goes to sleep and no other thread can be scheduled.

\paragraph{Address Spaces}



Our approach takes the best from both worlds.
%
We provide a general ``symbolic system call'' interface to the SEE, which provides built-in building blocks for thread context switching, address space isolation, memory sharing, and sleep operations (Table~\ref{table:cloud9:primitives}).
%
These are the minimal set of primitives that could not be easily emulated by guest code.
%
On top of this interface, we build as guest code models for complete operating system interfaces, such as POSIX.

The symbolic system call primitives can be implemented with little effort in an existing symbolic execution engine, by reusing existing functionality, as shown next.

\begin{table}
\renewcommand{\arraystretch}{1.1}
\addtolength{\tabcolsep}{-2pt}
{\small
\centering
\begin{tabular}{|l|l|}
\hline
~~~~~\textbf{Primitive Name} & ~~~~~~~~~~~~~~~~\textbf{Description} \\
\hline
 \cninesuffix\_make\_shared & Share memory across address spaces \\
\hline
\hline
  \cninesuffix\_thread\_create & \multirow{2}{4cm}{Create and destroy threads}\\
  \cninesuffix\_thread\_terminate & \\
  \cline{1-2}
   \cninesuffix\_process\_fork & \multirow{2}{4cm}{Fork and terminate the current process}\\
  \cninesuffix\_process\_terminate & \\
  \cline{1-2}
   \cninesuffix\_get\_context & Get the current context (pid and tid) \\
\hline
\hline
 \cninesuffix\_thread\_preempt & Preempt a thread  \\
 \hline 
 \cninesuffix\_thread\_sleep & Thread sleep on waiting queue \\
 \hline
 \cninesuffix\_thread\_notify & Wake threads from waiting queue \\
 \hline
 \cninesuffix\_get\_wlist & Create a new waiting queue \\
\hline
\end{tabular}
\caption{\cnine  primitives used to build the POSIX model.}
\label{table:cloud9:primitives}
}
\vspace{-3mm}
\end{table}

\paragraph{Address Spaces}

An SEE already supports cloning a program execution state at a symbolic branch.
%
We reuse this functionality to provide multiple address spaces within the same execution state.  Cloning the current address space is available to the guest through the \codebit{\cninesuffix\_process\_fork} primitive, which is used, for instance, to model the POSIX \codebit{fork()} call.

The address space in an execution state is typically represented as a mapping from memory locations (variables) to slots holding symbolic values.
%
We extend this functionality to allow locations from different mappings to point to the same slots.  This permits memory sharing between processes.
%
A memory location can be marked as shared by calling \codebit{\cninesuffix\_\allowbreak{}make\_\allowbreak{}shared}; it is then automatically mapped in the address spaces of the other processes in the execution state.  Whenever a shared object is modified in one address space, the new version is automatically propagated to the others.  The shared memory objects can then be used by the model as global memory for inter-process communication.

\paragraph{Multithreading and Scheduling}

The symbolic execution state of a program contains a stack holding the call chain and the local variables.
%
We implement support for multiple threads by maintaining multiple stacks within a state, each associated to an address space.
%
Threads are created in the currently executing process by calling \codebit{\cninesuffix\_\allowbreak{}thread\_\allowbreak{}create}.  \cnine's POSIX threads (pthreads) model makes use of this primitive in its own \codebit{pthread\_create()} routine.

To simplify synchronization inside the model, \cnine implements a cooperative scheduler.
%
An enabled thread runs uninterrupted (atomically), until either (a) the thread goes to sleep; (b) the thread is explicitly preempted by a \codebit{\cninesuffix\_\allowbreak{}thread\_\allowbreak{}preempt} call; or (c) the thread is terminated via symbolic system calls for process/thread termination. Preemption occurs at explicit points in the model code, but it is straightforward to extend \cnine to automatically insert preemptions calls at instruction level (as would be necessary, for instance, when testing for race conditions).

When \codebit{\cninesuffix\_\allowbreak{}thread\_sleep} is called, the SEE places the current thread on a specified waiting queue, and an enabled thread is selected for execution.
%
Another thread may call \codebit{\cninesuffix\_thread\_\allowbreak{}notify} on the waiting queue and wake up one or all of the queued threads.

\cnine can be configured to schedule the next thread deterministically, or to fork the execution state for each possible next thread.
%
The latter case is useful when looking for concurrency bugs, but it can be a significant source of path explosion, so it should be disabled when not needed.

If no thread can be scheduled when the current thread goes to sleep, then a hang is detected, the execution state is terminated,  and a corresponding test case is generated.


%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
