\subsection{Virtual Machine-based Languages: Java and C\#}

Beyond low-level system software, a significant amount of software is written in higher-level languages, offering features such as garbage collection, reflection, and built-in data structures.

Some of these languages, such as Java and C\#, are compiled to a lower-level bytecode representation and executed in a virtual machine.
%
The bytecode format is standardized and well-documented, which facilitates the development of dedicated symbolic execution engines for their runtimes.
%
For example, the Java PathFinder project~\cite{visser-jpf,jpf-symbex,jpf-testgen} provides a model checker and symbolic execution framework for Java bytecode.
%
Similarly, Pex~\cite{tillmann-pex} is a symbolic execution engine for .NET that has recently been distributed as part of the Visual Studio IDE.

The high-level environments pose additional challenges for symbolic execution related to the complexity of their data and execution model.  For example, symbolic program inputs can be both scalar and object-based.
%
Java PathFinder handles symbolic object inputs using a technique called generalized symbolic execution~\cite{generalized-symbex}, where symbolic objects are lazily initialized in response to the member accesses encountered during program execution.  Pex takes a similar approach for handling symbolic inputs in the .NET runtime.

\subsection{Dynamic Interpreted Languages}

The high-level languages that are never compiled, but source-interpreted, such as Python, JavaScript, Ruby, or Lua, are significantly more challenging for symbolic execution.
%
These languages have complex semantics that are under-specified, their features evolve rapidly from one version to another, and they rely on large built-in support libraries~\cite{dom2011,cutie-py,pythonReference}.
%
Building and maintaining a symbolic execution engine for these languages is a significant engineering effort.  As a result, the existing engines target only domain-specific subsets of their languages.

\paragraph{Supporting Symbolic Semantics}

Existing work addresses the problem of providing language semantics for symbolic execution in three major ways: by writing a symbolic interpreter for the language statements~\cite{nice}, executing the program concolically~\cite{cutie-py,jalangi}, and by requiring program cooperation~\cite{commuter}.

Writing a symbolic interpreter from scratch involves reconstructing the semantics for all the language constructs used by the target programs.  For example, the NICE-PySE~\cite{nice} symbolic execution engine, which is part of the NICE framework for testing OpenFlow applications, interprets the internal Python bytecode instructions generated by the interpreter when executing a program.  NICE-PySE is a Python application itself and uses the language reflection mechanisms to obtain, instrument and interpret the internal representation of the program.

The downside of writing a complete interpreter from scratch---including a symbolic execution engine---is that whenever a construct is not supported, the interpreter would halt.  To mitigate this, other engines take the concolic execution approach, where they run the real interpreter in concrete mode, and maintain in parallel the symbolic semantics of the language statements.  On the path segments where the symbolic semantics are not available, the execution can still make progress concretely, keeping the program state sound.  CutiePy~\cite{cutie-py} uses the tracing API of the Python interpreter to maintain the symbolic state in lockstep with the concrete execution.  The Jalangi dynamic instrumentation framework for JavaScript~\cite{jalangi} rewrites the target JavaScript program to insert statements for maintaining the symbolic state, similar to other symbolic execution engines for C programs~\cite{dart,cute,exe}.

In certain applications, symbolic execution is used to execute a model of a larger system, in the vein of model checking.  In this case, the model uses the specific API provided by the engine; the high-level language acts as a DSL, whose features are fully supported by the engine.
%
For example, the symbolic execution engine of the scalability testing tool Commuter~\cite{commuter} is entirely built in Python and offers an API for symbolically modeling operating system calls using the Python language.

%% In contrast to the existing techniques, \chef is the first system to use symbolic execution on an interpreter to symbolically execute a program written in the target interpreted language.  The closest work related to our approach is PokeEMU~\cite{hifi-lofi}, which uses symbolic execution on a reference CPU emulator to generate a test suite for checking the correctness of another emulator.  The generated test suite captures the semantics of the CPU instruction set, as implemented by the reference emulator.  However, the goal of PokeEMU is to check the implementation of the emulator, while in the case of \chef, we target the programs running in the interpreter.

\paragraph{Effectiveness of Symbolic Execution for Interpreted Languages}

The existing symbolic execution engines for interpreted languages have shown promise for finding bugs, in areas where these languages are increasingly popular, such as web applications~\cite{saxena-kudzu,artzi-apollo, kiezun-ardilla}.

For instance, the Kudzu~\cite{saxena-kudzu} symbolic execution engine for JavaScript was used to detect code injection vulnerabilities.  The Apollo~\cite{artzi-apollo} engine targets PHP code to detect runtime and HTML errors, while Ardilla~\cite{kiezun-ardilla} discovered SQL injection and cross-site scripting vulnerabilities in PHP applications.
%
This potential is also confirmed by our findings with \chef, whose engines for Python and Lua discovered hangs and unexpected exceptions in popular packages (Section~\ref{sec:eval:bug-finding}).

%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
