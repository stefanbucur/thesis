A lot of work in the area of model checking and symbolic execution~\cite{jhala2009software, woodcock2009formal}.  In this chapter, we focus on the use of symbolic execution for automated test case generation, applied on real-world software (complex structure, complex environment interface).

\section{Automated Testing Using Symbolic Execution}

Earliest symbolic execution: King~\cite{king:symbolic:2, boyer:symbolic}

Pure symbolic execution: KLEE~\cite{klee}, EXE~\cite{exe}

Whitebox fuzzing: SAGE~\cite{sage2012,godefroid:fuzz}, DART~\cite{dart}

Pex~\cite{tillmann-pex}

Security-oriented tools: Mayhem~\cite{mayhem}, AEG~\cite{aeg}

Testing as verification: Bounded model checkers: CBMC~\cite{cbmc}, LLBMC~\cite{llbmc2012}, F-Soft~\cite{f-soft}, Magic~\cite{magic}, Saturn~\cite{saturn}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Addressing Path Explosion}

Dealing with the path explosion problem: grammar-based whitebox fuzzing (abstracting inputs), MultiSE (merging states), using symbolic execution friendly primitives (OVerify), underconstrained execution (dealing with a single module at a time).

\subsection{Pruning}

\subsection{State Merging}

\subsection{Compositionality}

\subsection{Abstraction}

\subsection{Solver Optimizations}

Addressing the solver bottleneck: query caches, memory models (Mayhem only models symbolic reads)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Supporting Real-world Targets}

\subsection{System Software}

Handling real-world targets: C, C++ (KLOVER), parallel systems (explain the two ways to run these systems symbolically, depending on what bugs we're looking for).

Modeling the program environment: using the real environment, using abstractions.

\subsection{Interpreted Languages}

Jalangi for JavaScript using dynamic instrumentation.

Using the interpreter for symbolic execution: Lorenzo's paper (consider x86 as interpreted by Qemu or Bochs, then compare the two implementations to find bugs in the more complex one).

\subsection{Cooperating with the Symbolic Environment}

Cooperative symbolic execution (where the program uses special APIs of the engine).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Search Heuristics}

Group heuristics by their goals and their inputs (the state information they use).

Search Heuristics in Symbolic Execution

Generational search in SAGE.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Parallel Symbolic Execution}

Parallelizing Symbolic Execution : The work from Fujitsu, the work on JSP

Cloud Testing Services.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Interfaces for the Symbolic Execution Engine}

Symbolic tests: the work from MSR


%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
