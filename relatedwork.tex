There is substantial related work in the area of symbolic execution and formal methods in general.  In this chapter, we review the use of symbolic execution for automated test case generation (Section~\ref{sec:relwork:atcg}) and its applications on real-world software targets (Section~\ref{sec:relwork:targets}).  In particular, we focus on how previous work addressed the path explosion problem (Section~\ref{sec:relwork:pathexpl}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Symbolic Execution for Automated Testing of Commodity Software}

%% We review the most important symbolic execution-based tools.  The story is chronological, illustrating the advancements brought by each tool.

%% King~\cite{king:symbolic:2} described symbolic execution as a practical middle ground between testing a program with a set of concrete inputs and using formal correctness proofs.  The paper introduced EFFIGY, an interactive symbolic execution tool where developers manually step through paths and switch states in the execution tree.  However, the tool could only handle small programs written in a custom language supporting basic integer operations, and had limited performance, due to limited solver capabilities.

Symbolic execution was introduced almost four decades ago as a test case generation technique~\cite{king:symbolic:2, boyer:symbolic}.  The first tools worked on domain-specific languages, supported basic numeric operations, and were mostly used for interactive debugging.  The effectiveness of the technique on more complex programs was limited by the lack of efficient and expressive constraint solvers and slow hardware.

%% It was only in the past decade that symbolic execution has become a feasible approach to test generation for real-world software, with the advent of modern constraint solvers, such as Chaff~\cite{chaff}, MiniSAT~\cite{minisat}, STP~\cite{stp}, Z3~\cite{Z3}, or CVC~\cite{cvc}, and the exponential increase in hardware performance.  Our tools build on this foundation, too---both Cloud9 and Chef resort to the STP solver for all symbolic queries, such as branch feasibility checks.

The exponential increase in hardware performance and the availability of fast off-the-shelf constraint solvers~\cite{chaff,minisat,stp,Z3,cvc} amplified the research in symbolic execution.  Over the past decade, the new crop of symbolic execution engines generated test suites and found bugs on real-world software ranging from small system utilities to large application suites.

In this section, we highlight the most important tools and position \cnine and \chef with respect to them.

\subsection{System-level Software Targets}

%% \paragraph{DART}

%% DART automatically extracts the environment interface of a C program using static analysis.  DART augment the classic random fuzzing with a dynamic analysis that collects. The advantage of concrete execution is that DART can fall back on concrete semantics when symbolic ones are not supported (e.g., multiplications) DART detects standard errors such as crashes, assertion violations, and hangs.  Dart extracts the static interface of a program, consisting of global variables and inputs to the program entry function.  It concretizes calls to library functions.

%% Initializing values in DART: either randomly, or NULL or malloced values (for pointer types).  Chef and Cloud9 leaves it to the symbolic test the job of creating inputs. The basic primitives are marking allocated buffers (or integers or strings) as symbolic.
%% Dealing with environment inconsistencies in DART: Not a problem, as programs are re-executed (so no cross-talking in paths).  But assume no side effects in the program.
%% Solver in DART: lp\_solve (linear constraints of integers and reals).
%% DART was applied on C benchmarks and an implementation of the SIP protocol, finding hundreds of crashes.
%% DART uses DFS, BFS, or random.

%% \paragraph{CUTE}
%% Unit testing using concolic execution, with memory graphs as inputs.  Separates memory constraints from scalar constraints and keeps pointer constraints simple to keep the decision procedure tractable and efficient.
%% CUTE uses DFS.
%% CUTE uses its own in-house solver, built on top of lp\_solve, which adds optimizations such as incrementality.
%% CUTE supports generation of structured data by either calling sequences of operations, or solving data structure invariants (repOk operations), similar to Korat~\cite{boyapati:korat}.
%% Used for testing data structures.

\paragraph{Concrete + Symbolic Execution}

Targeting system software using symbolic execution is challenging, as the engine should support all program constructs, as well as the calls the program makes into its environment.
%
A solution adopted by early engines, such as DART~\cite{dart} and CUTE~\cite{cute}, was to instrument the original C source of the program, using tools such as CIL~\cite{cil}, with additional statements that maintain the symbolic state as the program executes.  This approach resulted in the so called \emph{concolic} (\emph{conc}rete + symb\emph{olic}) execution model, where the program executes normally with a concrete input, while collecting constraints for each branch taken, used to generate a new input for a new execution.
%
Whenever the symbolic execution was not supported, such as when dealing with external library calls, the program would simply stop collecting constraints and execute concrete-only.
%
Using this approach, DART and CUTE found crashes in C programs, such as protocol implementations and data structure libraries.

%% \paragraph{EXE}
%% Dedicated constraint solver STP, codesigned with EXE, optimized for reasoning about bitvectors and arrays, which accurately encode machine operations at good performance.
%% Has a flat view of memory.
%% Works by translating the C code to an instrumented format that includes checks for concrete/symbolic values, forks (UNIX forks), and checks for properties (memory errors, division by zero).
%% Introduced constraint optimization: caching, constraint independence.
%% DFS/BFS as search heuristics.
%% Found bugs in udhcpd, packet filters (BPF), pcre regexp library.

\paragraph{Specialized Solver Support}

In addition, non-trivial software also generates constraints that are hard to reason about, containing expressions such as memory accesses with symbolic addresses, or complex arithmetics such as bit-wise multiplications and divisions.  Without solver support, a symbolic execution engine needs to concretize the state or abandon the path, hence losing completeness.

To address this problem, modern symbolic execution engines employ off-the-shelf constraint solvers, such as Z3~\cite{Z3}, STP~\cite{stp}, or CVC~\cite{cvc}.  These solvers can reason efficiently about a large set of operations commonly encountered in program execution, such as bit-wise arithmetic and array access.
%
The EXE~\cite{exe} symbolic execution engine was among the first to employ such a solver (STP), co-designed with the symbolic execution engine to accurately express machine operations in languages such as C.
%
For example, EXE modeled the program memory as a flat array of bytes, with support for arbitrary pointer reads and writes, mixed with fixed-width integer operations.
%
As a result, EXE found bugs in system software such as the \codebit{udhcpd} DHPC server, packet filters, and the \codebit{pcre} Perl regular expression library.

\paragraph{Low-level Symbolic Interpretation}

Implementing symbolic execution semantics through source code instrumentation becomes difficult for large software with multiple units, or for more complex languages, such as C++.
%
As a result, the most recent (and most successful) symbolic execution engines target the lower-level compiled representations of programs, such as x86 binary or LLVM~\cite{llvm} bytecode~\cite{godefroid:fuzz,klee,bitBlaze,s2eSystem,mayhem}.  These representations consist of a smaller set of simpler instructions that are well specified and relatively stable.

%% \paragraph{SAGE}~\cite{sage2012,godefroid:fuzz}
%% Used in production, during Windows development, found thousands of vulnerabilities.  Largest known deployment of symbolic execution in production.
%% Targeted large applications, binary-level.
%% Introduces the generational search heuristic for finding bugs more efficiently in an incomplete search.

%% SAGE~\cite{sage2012,godefroid:fuzz} is the most successful use of symbolic execution in production.  It relies on concolic execution done at binary (x86) level.  It targets large applications with deep execution paths, such as Windows format parses and Microsoft Office applications.  To effectively explore the large search space, SAGE introduced a generational search heuristic.  The idea is to start from a concrete input that takes the program down a relevant path (e.g., a valid Office document), then alternate all branches on that path, then do the same with the second-generation inputs (hence the ``whitebox fuzzing'' name).
%% %
%% SAGE found thousands of Windows vulnerabilities at development time.

For example, SAGE~\cite{sage2012,godefroid:fuzz}---the most successful use of symbolic execution in production---performs concolic execution at binary level.
%
SAGE targets large applications with deep execution paths, such as Windows format parsers and Microsoft Office applications.
%
SAGE found thousands of Windows vulnerabilities at development time.

%% \paragraph{KLEE}
%% Uses symbolic execution for testing real-world systems code (Coreutils, Hi-star kernel, Busybox).  They built a high-performance symbolic execution engine that finds bugs in highly tested code and achieves high coverage levels.
%% Compact state representation using COW.
%% Uses a high-performance SMT solver (STP), and optimizes interface to the solver (constraint caching, expression simplifications).
%% Handles the environment problem through a model of files (used by the Coreutils), and external calls into the host environment.
%% Handles C code by compiling and running LLVM.
%% Uses static heuristics to maximize coverage, plus standard strategies.
%% Command line interface for marking inputs symbolic.

%% To target systems of increasing complexity, symbolic execution engines needed to address the environment problem.
%% %
%% KLEE~\cite{klee} was the first symbolic execution engine to target system software that communicates with its environment.  KLEE provides robust support for complex system software by having the software compiled to LLVM~\cite{llvm} IR, which is then interpreted symbolically.
%% %
%% KLEE~\cite{klee} introduced environment models as approximations of the real OS interface: the models replace parts of the standard C library and provided support for files.
%% %
%% This resulted in KLEE uncovering crashes and generating test suites with over 90\% coverage on average in the popular Coreutils utilities (e.g., \codebit{ls}, \codebit{echo}), testing Busybox and an OS kernel.
%% %
%% Our Cloud9 system builds on top of KLEE, providing symbolic primtives for a large fraction of the POSIX interface, as well as adding support for parallel symbolic execution.

KLEE~\cite{klee} is currently the most popular symbolic execution engine.  It is openly available and has served as a basis for a wide range of other tools.
%
KLEE works as a symbolic interpreter for LLVM IR bytecode, obtained by compiling source programs using an LLVM-based compiler such as Clang.
%
KLEE tackles the environment problem by introducing \emph{models} that approximate the real OS interface.  The KLEE models replace parts of the standard C library and provide basic support for file operations.  Unmodeled system calls are passed on to the host environment, executed concretely on behalf of the KLEE process.
%
KLEE found bugs and generated test suites with over 90\% statement coverage on average in the popular Coreutils suite.  It also found bugs in other systems software, such as Busybox and the HiStar kernel.

Modeling the environment is not always feasible.  In some cases, a component is so deeply integrated in the system that there is no clear separation between the component and the rest of the system.  Device drivers running in OS kernels are one notable example.
%
For those cases, an alternative approach to the environment problem is to bundle the program, together with all its dependencies, in one large unit executed symbolically.

S2E~\cite{s2eSystem} takes this approach by providing a full virtual machine x86 symbolic execution environment, which includes programs, libraries, the operating system, and the hardware.
%
This allows S2E to accurately run ``in-vivo'' any part of the software stack, without the need of the source code.
%
Most notably, S2E discovered vulnerabilities in several Windows device drivers, some of whom were Microsoft-certified~\cite{ddt}.

%% \paragraph{AEG}~\cite{aeg}
%% Automated testing with the specific purpose of generating proofs of vulnerabilities (exploits), i.e., inputs that explicitly hijack the program control flow and get a shell.
%% Takes as input LLVM + binary, produces exploit.
%% Generated 16 exploits on 14 open-source projects.
%% Buggy path-first heuristic: When a path has a bug (unexploitable), it is likely that it'll exhibit more bugs that could be exploitable.
%% Loop exhaustion strategy: prioritize paths exploring maximum number of iterations.
%% Symbolic files: simplifies KLEE's interface.
%% Symbolic sockets: supplies fresh symbolic data.
%% Environment variables (concrete values, fully symbolic, failures).
%% Network, multithreading, formatting functions (about 70 system calls).  Not clear how sound the support is, nor what happens when a syscall is not supported.

%% \paragraph{Mayhem}~\cite{mayhem}
%% Finds 29 exploitable vulnerabilities in Linux and Windows programs.
%% System designed to handle efficiently (at the expense of completeness) large state spaces generated by large programs.  Efficient reasoning about symbolic memory (symbolic writes are concretized, symbolic reads are replaced with nested ite expressions).
%% Uses only binaries (no debug info needed).

%% \paragraph{Bitblaze}~\cite{bitBlaze}
%% Unified binary analysis platform, used mainly for malware analysis.


Symbolic execution also found use in security testing~\cite{aeg,mayhem,bitBlaze}.  For this task, reaching vulnerabilities is more important than achieving completeness, so engines in this space resort to simplifications to increase performance and reach deeper executions in larger programs.
%
For example, the AEG~\cite{aeg} tool uses symbolic analysis to both find bugs and automatically generate exploits (get a shell) from the bugs.  AEG uses heuristics that prioritize buggt paths and employs simple operating system models that minimize path explosion.
%
The Mayhem~\cite{mayhem} tool employs a simplified symbolic memory model where write addresses are concretized.
%
Both tools found exploitable vulnerabilities in Linux and Windows programs.

%% Handling real-world targets: C, C++ (KLOVER), parallel systems (explain the two ways to run these systems symbolically, depending on what bugs we're looking for).

\subsection{Virtual Machine-based Languages: Java and C\#}

%% \paragraph{Java Path Finder}
%% \cite{jpf-symbex,jpf-testgen,generalized-symbex}.
%% Code that manipulates complex data structures.  Uses lazy initialization to instantiate data structures.
%% Built on top of the JVM.
%% Uses iterative deepening combined with DFS.
%% Model checking as a form of testing: since the program environment is typically way too large, model checking ends up being testing.
%% Can be used to either execute a repOk method and generate blackbox inputs, or do whitebox testing.

%% \paragraph{Pex}
%% Pex~\cite{tillmann-pex}.
%% Whitebox fuzzing for .NET.  Integrated in Visual Studio.  Found errors in a core .NET component.
%% Uses PUTs (parameterized unit tests)~\cite{tillmann-puts}.
%% Uses a ``meta-strategy'' that groups branches in equivalence classes, and then selects the lest chosen class.  Different sets of equivalence classes are chosen uniformly.
%% Constructing objects: run symbolically the object constructor.

Beyond low-level system software, a significant amount of software is written in higher-level languages, offering features such as garbage collection, reflection, and rich built-in data structures.

Some of these languages, such as Java and C\#, are compiled to a lower-level bytecode representation and executed in a virtual machine.
%
The bytecode format is standardized and well-documented, which facilitates the development of dedicated symbolic execution engines for their runtimes.
%
For example, the Java PathFinder project~\cite{visser-jpf,jpf-symbex,jpf-testgen} provides a model checker and symbolic execution framework for Java bytecode.
%
Similarly, Pex~\cite{tillmann-pex} is a symbolic execution engine for .NET that has recently been distributed as part of Visual Studio.

The high-level environments pose additional challenges for symbolic execution related to the complexity of their data and execution model.  For example, symbolic program inputs can now be both scalar and object-based.
%
Java PathFinder handles symbolic object inputs using a technique called generalized symbolic execution~\cite{generalized-symbex}, where symbolic objects are lazily initialized in response to the member accessess encountered during program execution.

\subsection{Dynamic Interpreted Languages}

The high-level languages that are never compiled, but source-interpreted, such as Python, JavaScript, Ruby, or Lua, are significantly more challenging for symbolic execution.
%
These languages have complex semantics that are under-specified, their features evolve rapidly from one version to another, and they rely on large built-in support libraries.
%
Building and maintaining a symbolic execution engine for these languages is a significant engineering effort.  As a result, the existing engines target only domain-specific subsets of their languages.

Three ways to address the problem: concolic execution of the interpreter, cooperative symbolic execution, and reflection with interpretation, dynamic instrumentation.

Despite the limitations, existing engines showed promising results for bug finding, especially in the realm of web applications.


To our knowledge, no symbolic execution engine for Lua exists.  For Python, we found three research tools, which we compare \chef to.  (1) \cutiepy~\cite{cutie-py} is a concolic engine based on a formal model of the Python language.  It uses a custom CPython interpreter to drive a concrete execution, along with updating the symbolic state according to model semantics. (2) NICE-PySE~\cite{nice} is part of the NICE framework for testing OpenFlow applications.  We will refer to it as \nicese, for brevity. It wraps supported data types into symbolic counterparts that carry the symbolic store, and uses Python's tracing mechanisms to implement the interpretation loop fully in Python.  (3) The symbolic execution engine of the scalability testing tool Commuter~\cite{commuter} is also entirely built in Python.  Its primary purpose is the construction of models that explicitly use an API of symbolic data types.

Jalangi for JavaScript using dynamic instrumentation.

Using the interpreter for symbolic execution: Lorenzo's paper (consider x86 as interpreted by Qemu or Bochs, then compare the two implementations to find bugs in the more complex one).

To the best of our knowledge, we are the first to use symbolic execution on an interpreter to symbolically execute a program written in the target interpreted language.  However, there has been work on writing dedicated symbolic execution engines for interpreted languages directly.  Beside Python engines, the Kudzu~\cite{saxena-kudzu} symbolic execution engine for JavaScript was used to detect code injection vulnerabilities. It relies on an intermediate representation of JavaScript that it directly executes symbolically.
%
Apollo~\cite{artzi-apollo} is another engine targeting PHP code to detect runtime and HTML errors, while Ardilla~\cite{kiezun-ardilla} uses this system to discover SQL injection and cross-site scripting attacks in PHP.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Approaches to the Environment Problem}

We now discuss in more detail the environment problem in symbolic execution and how existing work approaches it.

In order to efficiently achieve the testing goals for the target program, symbolic execution engines need to minimize the time spent in the environment, while ensuring correct behavior in the program.
%
The existing approaches fall into three categories: concretizing the calls into the environment, bundling the environment with the rest of the program, and abstracting (modeling) the environment.

\subsection{Over-approximation (Concretization)}

Concretizing calls into the environment can be easily done in concolic mode, by simply dropping the symbolic operations while the execution carries outside the program [cite CUTE, DART, SAGE].  In pure symbolic mode, an alternative is to call the environment of the host [cite KLEE].  The disadvantage is that different execution paths can interfere for stateful calls (e.g., resource operations).

\subsection{Abstraction (Modeling)}

The last approach is to replace a concrete interface implementation with a simplified one, as either part of the symbolic execution engine (e.g., symbolic hardware in S2E), or as guest code running at the same level as the target program (e.g., uClibc models in KLEE).  The simpler the model, the less path explosion, but may introduce unsoundness or missed bugs.

\subsection{Inlining (Whole-system Analysis)}

The opposite approach is to treat the program + environment as one large target.  Full-VM symbolic execution engines take this approach.  The problem is that path explosion in the entire system reduces the focus on the target program.  S2E introduced consistency models as a principled path pruning outside the module of interest.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Path Explosion Mitigation}

Dealing with the path explosion problem: grammar-based whitebox fuzzing (abstracting inputs), MultiSE (merging states), using symbolic execution friendly primitives (OVerify), underconstrained execution (dealing with a single module at a time).

\subsection{Search Heuristics}

Group heuristics by their goals and their inputs (the state information they use).

Search Heuristics in Symbolic Execution

Generational search in SAGE.

\subsection{Path Pruning}

Eliminate or deprioritize the paths are are less likely to lead to the exploration goal.  Goes hand in hand with prioritization heuristics.

Replace two states meeting in the CFG with one that combines the memory locations and path conditions of the two.  Doesn't lead to improvements all the time, due to increased solver overhead [cite Trevor Hansen's study].

Compositionality means executing symbolically individual functions and storing the disjunction of path conditions as a function summary.  Can be computed incrementally, in response to program executions [cite demand-driven].

\subsection{Improving Constraint Solving}

Addressing the solver bottleneck: query caches, memory models (Mayhem only models symbolic reads). Guarded sets in multiSE.

\subsection{Parallel Symbolic Execution}

Recently, \cite{parallelSymbex} described an extension to Java Pathfinder (JPF) that parallelizes symbolic execution by using parallel random searches on a static partition of the execution tree.  JPF pre-computes a set of disjoint constraints that, when used as preconditions on a worker's exploration of the execution tree, steer each worker to explore a subset of paths disjoint from all other workers.  In this approach, using constraints as preconditions imposes, at {\em every} branch in the program, a solving overhead relative to exploration without preconditions.  The complexity of these preconditions increases with the number of workers, as the preconditions need to be more selective.  Thus, per-worker solving overhead increases as more workers are added to the cluster.  This limits scalability: the largest evaluated program had 447 lines of code and did not interact with its environment.  Due to the {\em static} partitioning of the execution tree, total running time is determined by the worker with the largest subtree.  As a result, increasing the number of workers can even increase total test time instead of reducing it~\cite{parallelSymbex}.  \cnine mitigates these drawbacks.

Several sequential symbolic execution engines~\cite{godefroid:fuzz,dart,hct,klee} have had great success in automated testing. These state-of-the-art tools exhaust available memory and CPU fairly quickly.  \cnine can help such tools scale beyond their current limits, making symbolic execution a viable testing methodology for a wider spectrum of software systems.

\topic{To our knowledge, we are the first to scalably parallelize symbolic execution to shared-nothing clusters.} 
There has been work, however, on parallel model checking~\cite{parallelMurphi,distributed-spin,loadBalModelchecking,spin:multicore-modelchecking,modelCheckBDD}. The SPIN model checker has been parallelized two-way for dual-core machines~\cite{parallelSPIN}. Nevertheless, there are currently no model checkers that can scale to many loosely connected computers, mainly due to the overhead of coordinating the search across multiple machines and transferring explicit states. \cnine uses an encoding of states that is compact and enables better scaling.

The work from Fujitsu.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Symbolic Tests}

The general area of automated software testing has a rich body of published literature. We highlight here only the closest concepts. Symbolic tests are closely related to the idea of parameterized unit tests~\cite{tillmann-puts}. These extend regular unit tests with parameters marked as symbolic inputs during symbolic execution.
%
QuickCheck~\cite{quickcheck} allows writing specifications in Haskell, which again share their basic concept with symbolic tests, and tries to falsify them using random testing.  Symbolic execution can offer an alternative to random testing in evaluating QuickCheck test specifications.

The KLEE command line interface for marking symbolic arguments.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{UNSORTED}

Closely related to symbolic execution is the concept of bounded model checking (BMC).  Instead of exploring individual execution paths and generate test cases, a BMC unfolds the control flow graph of the program and constructs a verification condition---a formula encompassing the behavior of the entire program with respect to a property to be checked.  Popular model checkers include CBMC~\cite{cbmc}, LLBMC~\cite{llbmc2012}, F-Soft~\cite{f-soft}, Magic~\cite{magic}, or Saturn~\cite{saturn}.

Beyond symbolic execution, there is substantial work done in the field of model checking and formal methods in general, which goes beyond the scope of this thesis.  We refer the interested reader to survey papers that cover the topic in more breadth~\cite{jhala2009software, woodcock2009formal}.

Black-box (random) fuzzing.

Unsound approaches.

Cooperative symbolic execution (where the program uses special APIs of the engine).

OVerify.

%% \paragraph{Others}

%% Other older test input generation tools: \cite{genptrinputs}.

%% Korat~\cite{boyapati:korat}. Symstra~\cite{xie:symstra}.


%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
