\chapter*{Abstract (German)}

Testen von Software ist aufwändig, zeitintensiv, und fehleranfällig. Dennoch ist es in der Praxis die am häufigsten verwendete Methode zur Qualitätssicherung. Die Automatisierung des Testprozesses verspricht eine höhere Effektivität insbesondere zum Auffinden von Fehlern in Randfällen, welche beim manuellen Testen leicht übersehen werden. Symbolische Softwareausführung ist die populärste automatische Technik zum Testen von grossen, praxisnahen Softwareprojekten. Ihre Vorteile sind (1) keine falsch positiven Resultate, (2) abschliessendes Aufzählen aller Programmausführungen, und (3) die Möglichkeit, das Testen auf einen Teilbereich der Software zu fokussieren. In der Praxis limitiert jedoch das \emph{Umgebungsproblem} die Skalierbarkeit von symbolischer Ausführung: Um Programme auszuführen, welche auf ihre externe Umgebung zugreifen, muss die symbolische Ausführungsplattform diese Schnittstellen auf effiziente Weise bereitstellen. Es ist schwierig, das Umgebungsproblem ein für alle mal zu lösen, denn seine Natur hängt von der gegebenen Schnittstelle und ihrer Implementierung ab.

Diese Doktorarbeit behandelt zwei Fälle des Umgebungsproblems in symbolischer Ausführung, welche zusammen ein breites Spektrum von praxisrelevanter Software abdecken: (1) Systemprogramme, welche mit dem Betriebssystem interagieren, und (2) Programme, welche in höheren, dynamischen Sprachen wie Python, Ruby und JavaScript geschrieben sind. Diese beiden Fälle haben entgegengesetzte Eigenschaften: Betriebssystemschnittstellen sind typischerweise stabil und gut dokumentiert (z.B. POSIX); demgegenüber ist die exakte Funktionsweise von dynamischen Sprachen oft der Implementierung überlassen und entwickelt sich laufend weiter.

Der Beitrag dieser Doktorarbeit zum Lösen des Umweltproblems im Fall von stabilen Betriebssystemschnittstellen ist die Idee, das Modell des Betriebssystems in zwei Teile zu trennen: Ein Kern von primitiven Funktionen, welche direkt in die Hostumgebung integriert sind, und darauf aufbauend eine vollständige Emulation des Betriebssystems innerhalb der zu testenden Gastumgebung. Bereits drei primitive Funktionen genügen, um eine komplexe Schnittstelle wie POSIX zu unterstützen: Threads und Prozesse, Synchronisation, und Adressräume mit gemeinsam genutzten Speicher. Unser Prototyp dieser Idee ist \emph{\cnine}, eine symbolische Ausführungsplattform mit einem genauen und effizienten Modell der POSIX-Schnittstelle, wie sie von Systemprogrammen, Webservern und verteilten Systemen benutzt wird. \cnine ist unter {\urlstyle{same}\url{http://cloud9.epfl.ch}} verfügbar.

Für Programme in dynamischen Sprachen stellt diese Arbeit die Idee vor, den Interpreter der Programmiersprache als „ausführbare Spezifikation” zu verwenden. Der Interpreter läuft in einer maschinennahen symbolischen Testumgebung (z.B. auf der Ebene von X86) und führt das zu testende Programm aus. Das Gesamtsystem wird dadurch zu einer symbolischen Testumgebung auf der Ebene der dynamischen Sprache. Um die Komplexität zu bewältigen, die durch das Ausführen des Interpreters entsteht, wird in dieser Arbeit die klassenuniforme Pfadanalyse (CUPA, class-uniform path analysis) eingeführt, eine Heuristik zur Prioritisierung von Pfaden. CUPA gruppiert Pfade in Äquivalenzklassen basierend auf Zielvorgaben der Analyse. Wir verwirklichten diese Ideen in unserem Prototyp \emph{\chef}, einer symbolischen Ausführungsumgebung für interpretierte Sprachen: {\urlstyle{same}\url{http://dslab.epfl.ch/proj/chef}}.

\noindent \textbf{Keywords:} Symbolische Ausführung, Programmumgebungen, Systemsoftware, interpretierte Programmiersprachen.

\chapter*{Abstract}

Manual software testing is laborious and prone to human error, yet it is the most common quality assurance method used in practice.  Automating the test case generation promises better effectiveness, especially for exposing corner-case bugs.
%
\emph{Symbolic execution} stands out as an automated testing technique that has no false positives, it eventually enumerates all feasible program executions, and can prioritize executions of interest.
%
However, path explosion---the number of program executions being exponential in the program size---hinders the applicability of symbolic execution in the real world, where software commonly reaches millions of lines of code.

In practice, large systems can be efficiently executed symbolically by exploiting their modularity.
%
However, by separately executing a component that depends on its environment, a symbolic execution engine needs to provide an environment interface that is efficient, while maintaining accuracy and completeness, a conundrum known as the \emph{environment problem}.
%
Systematically addressing the environment problem is challenging, as its instantiation depends on the nature of the environment and its interface.

This thesis addresses two instances of the environment problem in symbolic execution, which reside at opposite points on the \emph{interface stability} axis: (1) system software interacting with an operating system with stable and well-documented semantics (e.g., POSIX), and (2) high-level programs written in dynamic languages, such as Python, Ruby, or JavaScript, whose semantics and interfaces are continuously evolving.

To address the environment problem for stable operating system interfaces, this thesis introduces the idea of splitting an operating system model into a core set of primitives built into the engine and, on top, the full operating system interface emulated inside the guest.
%
As few as two primitives are sufficient to support a complex interface such as POSIX: threads with synchronization and address spaces with shared memory.
%
We prototyped this idea in the \emph{\cnine} symbolic execution platform. \cnine's accurate and efficient POSIX model exposed hard-to-reproduce bugs in systems such as UNIX utilities, web servers, and distributed systems.
%
\cnine is available at {\urlstyle{same}\url{http://cloud9.epfl.ch}}.

For programs written in high-level interpreted languages, this thesis introduces the idea of using the language interpreter as an ``executable language specification''.  The interpreter runs inside a low-level (e.g., x86) symbolic execution engine, while it executes the target program.  The aggregate system acts as a high-level symbolic execution engine for the program.
%
To manage the complexity of symbolically executing the entire interpreter, this thesis introduces Class-Uniform Path Analysis (CUPA), a heuristic for prioritizing paths that groups paths into equivalence classes according to a coverage goal.
%
We prototyped these ideas in the \emph{\chef} symbolic execution platform for interpreted languages, which generated up to 1000 times more tests in popular Python and Lua packages compared to a plain execution of the interpreters.
%
\chef is available at {\urlstyle{same}\url{http://dslab.epfl.ch/proj/chef/}}.

\noindent \textbf{Keywords:} Symbolic execution, program environments, systems software, interpreted languages.


%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
