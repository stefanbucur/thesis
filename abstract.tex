\chapter*{Abstract (German)}

Testen von Software ist aufwändig, zeitintensiv, und fehleranfällig. Symbolische Ausführung von Software ist eine vielversprechende Technik zum automatischen Erstellen von Testfällen. In der Praxis limitiert jedoch das Umgebungsproblem die Skalierbarkeit von symbolischer Ausführung: Software ist auf komplexe Schnittstellen zu ihrer Umgebung angewiesen, und die symbolische Ausführungsplattform sollte diese Schnittstellen bereitstellen. Es ist schwierig, das Umgebungsproblem ein für alle mal zu lösen, denn seine Natur hängt von der gegebenen Schnittstelle und ihrer Implementierung ab.

Diese Doktorarbeit behandelt zwei Fälle des Umgebungsproblems, welche zusammen ein breites Spektrum von praxisrelevanter Software abdecken: (1) Systemprogramme, welche mit dem Betriebssystem interagieren, und (2) Programme, welche in höheren, dynamischen Sprachen wie Python, Ruby oder JavaScript geschrieben sind. Diese beiden Fälle haben entgegengesetzte Eigenschaften: Betriebssystemschnittstellen sind typischerweise stabil und gut dokumentiert (z.B. POSIX); demgegenüber sind die Spezifikationen von dynamischen Sprachen partiell und unbeständig.

Um das Umgebungsproblem im Fall von stabilen Betriebssystemschnittstellen zu lösen, stellt diese Doktorarbeit \emph{\cnine} vor: eine Plattform zur symbolischen Ausführung mit einem genauen und effizienten Modell der POSIX Schnittstellen, wie sie von Systemprogrammen, Webservern und verteilten Systemen benutzt werden. \cnine beruht auf der Erkenntnis, dass die Betriebssystemschnittstelle zu Testzwecken durch ein Modell ersetzt werden kann, welches innerhalb der Testumgebung läuft und auf wenigen grundlegenden Abstraktionen aufbaut: Threads und Prozesse, Synchronisation und Adressräume mit gemeinsam genutztem Speicher. Diese Abstraktionen müssen als primitive Operationen von der symbolischen Ausführungsplattform bereitgestellt werden, während die restlichen Teile des Modells innerhalb der Testumgebung emuliert werden können.

Für den Fall der partiellen und unbeständigen Spezifikationen von dynamischen Sprachen stellt diese Arbeit \emph{\chef} vor. \chef erstellt symbolische Ausführungsplattformen für dynamische Sprachen, indem es deren Interpreter als ausführbare Spezifikation verwendet. \chef führt das zu testende Programm gemeinsam mit dem Interpreter auf maschinennaher Ebene (z.B. x86) symbolisch aus, so dass das Gesamtsystem zu einer symbolischen Ausführungsplattform auf höherer Ebene wird. \chef reduziert die Komplexität dieses Ansatzes mittels klassen-uniformer Pfadanalyse (class-uniform path analysis, CUPA), einer Heuristik zur Priorisierung von Pfaden. CUPA gruppiert Pfade in Äquivalenzklassen basierend auf Zielvorgaben der Analyse. 

\noindent \textbf{Keywords:} Symbolische Ausführung, Programmumgebungen, Systemsoftware, interpretierte Programmiersprachen.

\chapter*{Abstract}

Manual software testing is laborious, time-consuming, and subject to human error, yet it is the most common quality assurance method used in practice.
%
Automating the test case generation promises better effectiveness, especially for exposing corner-case bugs.
%
Symbolic execution is the most popular automated testing technique to be applied on real-world software, as it has no false positives, it eventually enumerates all program executions that are feasible, and none other, and can focus on parts of larger systems.
%
However, its scalability is limited by the \emph{environment problem}: to execute a program that relies on external functionality---its environment---the symbolic execution engine needs to efficiently provide the environment interface.
%
Systematically addressing the environment problem is challenging, as its instantiation depends on the nature of the environment and its interface.

This thesis addresses two instances of the environment problem in symbolic execution, which collectively cover a wide range of real-world software: (1) system software interacting with the operating system, and (2) high-level programs written in dynamic languages, such as Python, Ruby, or JavaScript.
%
The two instances exhibit opposite characteristics: on the one hand, operating system interfaces and semantics are typically stable and well documented (e.g., POSIX), while on the other hand modern interpreted languages have semantics and interfaces that are continuously evolving.

To address the environment problem for stable operating system interfaces, this thesis introduces the idea of splitting an operating system model into a core set of primitives built into the engine and, on top, the full operating system interface emulated inside the guest.
%
As few as three primitives are sufficient to support a complex interface such as POSIX: threads and processes, synchronization, and address spaces with shared memory.
%
We prototyped this idea in the \emph{\cnine} symbolic execution platform. \cnine provides an accurate and efficient model of the POSIX interface, as used by system such as UNIX utilities, web servers, and distributed systems.
%
\cnine is available at {\urlstyle{same}\url{http://cloud9.epfl.ch}}.

For programs written in high-level interpreted languages, this thesis introduces the idea of using the language interpreter as an ``executable language specification''.  The interpreter runs inside a low-level (e.g., x86) symbolic execution engine, while it executes the target program.  The aggregate system acts as a high-level symbolic execution engine for the program.
%
To manage the complexity of symbolically executing the entire interpreter, this thesis introduces Class-Uniform Path Analysis (CUPA), a heuristic for prioritizing paths that groups paths into equivalence classes according to a coverage goal.
%
We prototyped this idea in the \emph{\chef} symbolic execution platform for interpreted languages, available at {\urlstyle{same}\url{http://dslab.epfl.ch/proj/chef/}}.

\noindent \textbf{Keywords:} Symbolic execution, program environments, systems software, interpreted languages.


%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
