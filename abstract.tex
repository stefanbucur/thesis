\chapter*{Abstract (German)}

Testen von Software ist aufwändig, zeitintensiv, und fehleranfällig. Dennoch ist es in der Praxis die am häufigsten verwendete Methode zur Qualitätssicherung. Die Automatisierung des Testprozesses verspricht eine höhere Effektivität insbesondere zum Auffinden von Fehlern in Randfällen, welche beim manuellen Testen leicht übersehen werden. Symbolische Softwareausführung ist die populärste automatische Technik zum Testen von grossen, praxisnahen Softwareprojekten. Ihre Vorteile sind (1) keine falsch positiven Resultate, (2) abschliessendes Aufzählen aller Programmausführungen, und (3) die Möglichkeit, das Testen auf einen Teilbereich der Software zu fokussieren. In der Praxis limitiert jedoch das \emph{Umgebungsproblem} die Skalierbarkeit von symbolischer Ausführung: Um Programme auszuführen, welche auf ihre externe Umgebung zugreifen, muss die symbolische Ausführungsplattform diese Schnittstellen auf effiziente Weise bereitstellen. Es ist schwierig, das Umgebungsproblem ein für alle mal zu lösen, denn seine Natur hängt von der gegebenen Schnittstelle und ihrer Implementierung ab.

Diese Doktorarbeit behandelt zwei Fälle des Umgebungsproblems in symbolischer Ausführung, welche zusammen ein breites Spektrum von praxisrelevanter Software abdecken: (1) Systemprogramme, welche mit dem Betriebssystem interagieren, und (2) Programme, welche in höheren, dynamischen Sprachen wie Python, Ruby und JavaScript geschrieben sind. Diese beiden Fälle haben entgegengesetzte Eigenschaften: Betriebssystemschnittstellen sind typischerweise stabil und gut dokumentiert (z.B. POSIX); demgegenüber ist die exakte Funktionsweise von dynamischen Sprachen oft der Implementierung überlassen und entwickelt sich laufend weiter.

Der Beitrag dieser Doktorarbeit zum Lösen des Umweltproblems im Fall von stabilen Betriebssystemschnittstellen ist die Idee, das Modell des Betriebssystems in zwei Teile zu trennen: Ein Kern von primitiven Funktionen, welche direkt in die Hostumgebung integriert sind, und darauf aufbauend eine vollständige Emulation des Betriebssystems innerhalb der zu testenden Gastumgebung. Bereits drei primitive Funktionen genügen, um eine komplexe Schnittstelle wie POSIX zu unterstützen: Threads und Prozesse, Synchronisation, und Adressräume mit gemeinsam genutzten Speicher. Unser Prototyp dieser Idee ist \emph{\cnine}, eine symbolische Ausführungsplattform mit einem genauen und effizienten Modell der POSIX-Schnittstelle, wie sie von Systemprogrammen, Webservern und verteilten Systemen benutzt wird. \cnine ist unter {\urlstyle{same}\url{http://cloud9.epfl.ch}} verfügbar.

Für Programme in dynamischen Sprachen stellt diese Arbeit die Idee vor, den Interpreter der Programmiersprache als „ausführbare Spezifikation” zu verwenden. Der Interpreter läuft in einer maschinennahen symbolischen Testumgebung (z.B. auf der Ebene von X86) und führt das zu testende Programm aus. Das Gesamtsystem wird dadurch zu einer symbolischen Testumgebung auf der Ebene der dynamischen Sprache. Um die Komplexität zu bewältigen, die durch das Ausführen des Interpreters entsteht, wird in dieser Arbeit die klassenuniforme Pfadanalyse (CUPA, class-uniform path analysis) eingeführt, eine Heuristik zur Prioritisierung von Pfaden. CUPA gruppiert Pfade in Äquivalenzklassen basierend auf Zielvorgaben der Analyse. Wir verwirklichten diese Ideen in unserem Prototyp \emph{\chef}, einer symbolischen Ausführungsumgebung für interpretierte Sprachen: {\urlstyle{same}\url{http://dslab.epfl.ch/proj/chef}}.

\noindent \textbf{Keywords:} Symbolische Ausführung, Programmumgebungen, Systemsoftware, interpretierte Programmiersprachen.

\chapter*{Abstract}

Manual software testing is laborious, time-consuming, and subject to human error, yet it is the most common quality assurance method used in practice.
%
Automating the test case generation promises better effectiveness, especially for exposing corner-case bugs.
%
Symbolic execution is the most popular automated testing technique to be applied to real-world software, as it has no false positives, it eventually enumerates all program executions that are feasible, and none other, and can focus on parts of larger systems.
%
However, its scalability is limited by the \emph{environment problem}: to execute a program that relies on external functionality---its environment---the symbolic execution engine needs to efficiently provide the environment interface.
%
Systematically addressing the environment problem is challenging, as its instantiation depends on the nature of the environment and its interface.

This thesis addresses two instances of the environment problem in symbolic execution, which collectively cover a wide range of real-world software: (1) system software interacting with the operating system, and (2) high-level programs written in dynamic languages, such as Python, Ruby, or JavaScript.
%
The two instances exhibit opposite characteristics: on the one hand, operating system interfaces and semantics are typically stable and well documented (e.g., POSIX), while on the other hand modern interpreted languages have semantics and interfaces that are continuously evolving.

To address the environment problem for stable operating system interfaces, this thesis introduces the idea of splitting an operating system model into a core set of primitives built into the engine and, on top, the full operating system interface emulated inside the guest.
%
As few as three primitives are sufficient to support a complex interface such as POSIX: threads and processes, synchronization, and address spaces with shared memory.
%
We prototyped this idea in the \emph{\cnine} symbolic execution platform. \cnine provides an accurate and efficient model of the POSIX interface, as used by system such as UNIX utilities, web servers, and distributed systems.
%
\cnine is available at {\urlstyle{same}\url{http://cloud9.epfl.ch}}.

For programs written in high-level interpreted languages, this thesis introduces the idea of using the language interpreter as an ``executable language specification''.  The interpreter runs inside a low-level (e.g., x86) symbolic execution engine, while it executes the target program.  The aggregate system acts as a high-level symbolic execution engine for the program.
%
To manage the complexity of symbolically executing the entire interpreter, this thesis introduces Class-Uniform Path Analysis (CUPA), a heuristic for prioritizing paths that groups paths into equivalence classes according to a coverage goal.
%
We prototyped this idea in the \emph{\chef} symbolic execution platform for interpreted languages, available at {\urlstyle{same}\url{http://dslab.epfl.ch/proj/chef/}}.

\noindent \textbf{Keywords:} Symbolic execution, program environments, systems software, interpreted languages.


%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
