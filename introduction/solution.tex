This thesis leverages the insight that the distribution of environment instances is skewed, with some types of interfaces being more common than others.
%
Instead of attacking the entire range, this thesis addresses \emph{two} of the most common instances of the environment problem:  (1) software interacting with the operating system, and (2) high-level programs written in dynamic languages, such as Python, Ruby, and JavaScript.
%
The operating system interface is used by virtually all systems software, as it is the only way for a process to access resources in a modern operating system.
%
For programs written in high-level dynamic languages, the environment is the language runtime---an interpreter or virtual machine.  Dynamic languages are increasignly popular for developing web applications and for system integration.  In January 2015, the top 4 languages used in open-source repositories on GitHub and on Stack Overflow were JavaScript, Java, PHP, and Python~\cite{lang-stats-2015}.

While both interfaces provide deep abstractions and strong encapsulation, they exhibit opposite characteristics in terms of stability and size.

On the one hand, an operating system interface is stable and well documented.
%
Moreover, while the interface consist of hundreds of system calls, they operate with simple data types---integers and memory buffers---and their usage follows a power-law distribution, such that most software only uses a small fraction of them.

On the other hand, the interface of a dynamic language runtime is only partially specified and the specification changes frequently.
%
Moreover, the language relies heavily on hundreds of built-in functions, such as string operations, data structure manipulation, and parsers, which are used thoroughly in most programs.
%
These functions are not implemented in the language itself, but are part of the runtime implementation, typically written in C.


\subsection{Symbolic Models for a Stable Operating System Interface}

To address the environment problem for operating system interfaces, this thesis introduces the idea of using a split environment model:
%
a core set of operating system primitives is built into the symbolic execution engine and the full operating system interface is emulated on top, as guest code.

Our insight is that as few as \emph{three} primitives are sufficient to support complex operating system interfaces such as POSIX: threads and processes, synchronization, and address spaces with shared memory.
%
This results in a substantially simpler implementation in the symbolic execution engine, with opportunities of reusing existing symbolic execution primitives.

We prototyped our design in the \emph{\cnine} symbolic execution platform for POSIX programs.  In under 7 KLOC, \cnine provides accurate and efficient models for files, network sockets, threads, processes, synchronization, IPC, signals, and other functions.
%
We used \cnine to test complex system utilities such as \textsf{curl}, web servers such as Apache and lighttpd, and other networked services, such as memcached.
%
As a result, \cnine uncovered new bugs, including a security vulnerability in memcached, and generated high-coverage test suites.


\subsection{Using Interpreters as Specifications for Fast-changing Languages}

For programs written in high-level dynamic languages, such as Python, Ruby, or JavaScript, the environment problem lends itself to a different approach.
%
Building a symbolic execution engine by hand for these languages is a significant engineering undertaking.  The language semantics are complex, loosely specified, and change frequently.  Moreover, they rely heavily on built-in functionality that ought to be modeled in the symbolic execution engine.

This thesis introduces the idea of using the language interpreter---the de facto standard of the language semantics---as an ``executable language specification'': the interpreter runs in a lower-level (e.g., x86) symbolic execution engine, while it executes the target program.  In turn, the aggregate system acts as a high-level symbolic execution engine for the target program.

To map the low-level interpreter paths to high-level program paths, we partition the interpreter paths into chunks, one for each high-level instruction executed on the path. Then, the low-level paths with the same sequence of high-level instructions map to the same high-level path.

To circumvent the path explosion arising in the interpreter, we introduce Class-uniform Path Analysis (CUPA), a family of path prioritization heuristics for maximizing a given coverage metric.
%
CUPA works by grouping paths into equivalence classes, according to a coverage goal.  The prioritization is done by uniformly choosing groups instead of paths.  As a result, any path selection bias introduced by program locations with higher path explosion is contained within one equivalence class.

We prototyped these ideas in the \chef symbolic execution platform for interpreted languages.  With \chef, we obtained engines for Python and Lua, which generated test suites and found bugs in popular library packages.

%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End: 
