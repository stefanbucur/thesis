In this chapter, we evaluate the research ideas described in the thesis.
%
We built prototypes for \cnine (Section~\ref{sec:eval:cnine-proto}) and \chef (Section~\ref{sec:eval:chef-proto}), which we use to demonstrate the effectiveness and efficiency of their techniques.
%
After presenting our methodology (Section~\ref{sec:eval:methodology}), we structure the evaluation by answering the following questions:
\begin{enumerate}
\item Can \chef and \cnine symbolically execute real-world software (Section~\ref{sec:eval:targets})?
\item Are the symbolic execution engines effective for bug finding and test suite generation (Section~\ref{sec:eval:bug-finding})?
\item Given the overhead of using the language interpreter, how efficient is \chef's test suite generation (Section~\ref{sec:eval:chef-efficiency})?
\item Does parallel symbolic execution, which our testing service builds upon, scale on commodity clusters (Section~\ref{sec:eval:cnine-efficiency})?
\end{enumerate}

\section{The \cnine Prototype}
\label{sec:eval:cnine-proto}
\input{evaluation/cloud9-proto}

\section{The Chef Prototype and Case Studies}
\label{sec:eval:chef-proto}
\input{evaluation/chef-proto}

\section{Methodology}
\label{sec:eval:methodology}
\input{evaluation/methodology}

\section{Testing Targets}
\label{sec:eval:targets}
\input{evaluation/targets}

\section{Effectiveness for Bug Finding and Test Generation}
\label{sec:eval:bug-finding}
\input{evaluation/bugs}

\section{Efficiency of Test Generation with \chef}
\label{sec:eval:chef-efficiency}
\input{evaluation/chef-efficiency}

\section{Scalability of Parallel Symbolic Execution in \cnine}
\label{sec:eval:cnine-efficiency}
\input{evaluation/cloud9-efficiency}

\section{Summary}

In this chapter, we presented the \cnine and \chef symbolic execution platforms for systems interacting with the POSIX operating system and programs written in interpreted languages, respectively.
%
We demonstrated that they can find bugs and generate test suites in wide range of real-world software, from UNIX utilities to web servers and popular Python and Lua packages.
%
\cnine's POSIX model based on the split model approach was crucial in uncovering bugs in the program interaction with the operating systems, such as bugs resulting from mishandling the fragmentation of a TCP stream.
%
\chef's use of the interpreter as as executable specification provided complete and correct semantics of the language, which enabled it to target popular Python and Lua packages.

Finally, we showed promising results in our future plan of bulding a cloud-based distributed symbolic execution platform, by demonstrating linear scalability of our symbolic execution parallelization algorithm on a workload of UNIX utilities.


%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
