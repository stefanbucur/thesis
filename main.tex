\iffalse % CHANGE TO iffalse FOR RELEASE
\documentclass[letterpaper,10pt,oneside]{book}
\usepackage[compact]{titlesec}   % Reduce the space between titles and text
\titleclass{\chapter}{straight}
\titleformat{\chapter}[display]
  {\normalfont\huge\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titlespacing*{\chapter} {0pt}{50pt}{40pt}
\else
\documentclass[letterpaper,12pt]{book}
\usepackage{setspace}
\onehalfspacing
\fi


\usepackage{geo}
\renewcommand{\topic}[1]{#1}
\usletter

\usepackage[utf8]{inputenc}        % UTF code sequences in the input
\usepackage{times}                 % Times New font
\usepackage{pifont}                % Ding symbols (for Cloud9)
\usepackage{wasysym}               % For the bullets in the interpreter comparison (Chef)
\usepackage{multirow}              % Cells spanning rows in tables
\usepackage{xspace}
\usepackage[labelfont=bf]{caption} % Bold caption labels
\usepackage{wrapfig}               % Side figures without caption




%% Global definitions
\newcommand{\thesistitle}{Improving Scalability of Symbolic Execution for Software with Complex Environment Interfaces}

%\newcommand{\codebit}[1]{\textsf{\footnotesize #1}}
\newcommand{\codebit}[1]{\texttt{\footnotesize \bfseries #1}}

%% Cloud9 definitions
\newcommand{\cnine}{Cloud9\xspace}
\newcommand{\cninesuffix}{cloud9}

%% Chef definitions

\newcommand{\chef}{\textsc{Chef}\xspace}

\newcommand{\cupa}{{\small CUPA}\xspace}
\newcommand{\hlpc}{{\small HLPC}\xspace}
\newcommand{\hlpcs}{{\small HLPC}s\xspace}

\newcommand{\nicese}{NICE\xspace}
\newcommand{\cutiepy}{CutiePy\xspace}
\newcommand{\commuterse}{Commuter\xspace}


\usepackage{type1cm}
\usepackage{eso-pic}
% Use pdfsync in draft mode
%\usepackage{pdfsync}

\makeatletter
\AddToShipoutPicture{%
            \setlength{\@tempdimb}{.50\paperwidth}%
            \setlength{\@tempdimc}{.97\paperheight}%
            \setlength{\unitlength}{1pt}%
            \put(\strip@pt\@tempdimb,\strip@pt\@tempdimc){%
        \makebox(0,0){\textcolor[gray]{0.75}%
        {\fontsize{8mm}{8mm}\selectfont{DRAFT}}}}%
}
\AddToShipoutPicture{%
            \setlength{\@tempdimb}{.50\paperwidth}%
            \setlength{\@tempdimc}{.03\paperheight}%
            \setlength{\unitlength}{1pt}%
            \put(\strip@pt\@tempdimb,\strip@pt\@tempdimc){%
        \makebox(0,0){\textcolor[gray]{0.75}%
        {\fontsize{8mm}{8mm}\selectfont{DRAFT}}}}%
}
\makeatother



%% PDF SUPPORT
%% -----------

\usepackage[hidelinks]{hyperref} % Add cross references inside the PDF
\usepackage[all]{hypcap} % Fix the jump position when clicking figure references

\hypersetup{
  pdftitle={\thesistitle},
  pdfauthor={Stefan Bucur}
}

\begin{document}

\date{}
\title{\thesistitle}
\author{Stefan Bucur \\ EPFL, Switzerland}

\maketitle

\chapter*{Abstract (German)}

Testen von Software ist aufwändig, zeitintensiv, und fehleranfällig. Symbolische Softwareausführung ist eine vielversprechende Technik zum automatischen Erstellen von Testfällen. In der Praxis limitiert jedoch das Umgebungsproblem die Skalierbarkeit von symbolischer Ausführung: Software ist auf komplexe Schnittstellen zu ihrer externen Umgebung angewiesen, und die symbolische Ausführungsplattform sollte diese Schnittstellen bereitstellen. Es ist schwierig, das Umgebungsproblem ein für alle mal zu lösen, denn seine Natur hängt von der gegebenen Schnittstelle und ihrer Implementierung ab.

Diese Doktorarbeit behandelt zwei Fälle des Umgebungsproblems, welche zusammen ein breites Spektrum von praxisrelevanter Software abdecken: (1) Systemprogramme, welche mit dem Betriebssystem interagieren, und (2) Programme, welche in höheren, dynamischen Sprachen wie Python, Ruby und JavaScript geschrieben sind. Diese beiden Fälle haben entgegengesetzte Eigenschaften: Betriebssystemschnittstellen sind typischerweise stabil und gut dokumentiert (z.B. POSIX); demgegenüber sind die Spezifikationen von dynamischen Sprachen unvollständig und instabil.

Um das Umweltproblem im Fall von stabilen Betriebssystemschnittstellen zu lösen, stellt diese Doktorarbeit \emph{\cnine} vor: eine Plattform zur symbolischen Ausführung mit einem genauen und effizienten Modell der POSIX Schnittstellen, wie sie von Systemprogrammen, Webservern und verteilten Systemen benutzt werden. \cnine beruht auf der Erkenntnis, dass die Betriebssystemschnittstelle zu Testzwecken durch ein Modell ersetzt werden kann, welches innerhalb der Testumgebung läuft und auf wenigen grundlegenden Abstraktionen aufbaut: Threads und Prozesse, Synchronisation, und Addressräume mit gemeinsam genutzten Speicher. Dieses Abstraktionen müssen als primitive Operationen von der symbolischen Ausführungsplattform bereitgestellt werden, während die restlichen Teile des Modells innerhalb der Testumgebung emuliert werden können.

Für den Fall der unvollständigen und instabilen Semantik von dynamischen Sprachen stellt diese Arbeit \emph{\chef} vor. \chef erstellt symbolische Ausführungsplattformen für dynamische Sprachen, indem es deren Interpreter als ausführbare Spezifikation verwendet. \chef führt das zu testende Programm gemeinsam mit dem Interpreter auf maschinennaher Ebene (z.B. x86) symbolisch aus, so dass das Gesamtsystem zu einer symbolischen Ausführungsplattform auf höherer Ebene wird. \chef reduziert die Komplexität dieses Ansatzes mittels klassen-uniformer Pfadanalyse (class-uniform path analysis, CUPA), einer Heuristik zur Priorisierung von Pfaden. CUPA gruppiert Pfade in Äquivalenzklassen basierend auf Zielvorgaben der Analyse. 

\noindent \textbf{Keywords:} Symbolische Ausführung, Programmumgebungen, Systemsoftware, interpretierte Programmiersprachen.

\chapter*{Abstract}

Software testing is laborious, time-consuming, and prone to human error.  Symbolic execution is a promising technique for automating test case generation.  However, its scalability to real-world software is limited by the \emph{environment problem}, i.e., the reliance of the target program on external functionality provided through complex interfaces, which the symbolic execution engine ought to support.
%
The environment problem is challenging to attack systematically, as its manifestations depend on the nature of the environment interface and its implementation.

This thesis addresses two instances of the environment problem, which collectively cover a wide range of real-world software: (1) system software interacting with the operating system, and (2) high-level programs written in dynamic languages, such as Python, Ruby, or JavaScript.  The two instances exhibit opposite characteristics: while the operating system interfaces are typically stable and well-documented (e.g., POSIX), the specifications of dynamic languages are incomplete and unstable.

To address the environment problem for stable operating system interfaces, this thesis introduces \emph{\cnine}, a symbolic execution platform that provides an accurate and efficient model of the POSIX interface, as used by systems such as system utilities, web servers, or distributed systems.
%
\cnine relies on the insight that, for the purpose of testing, the operating system interface can be modeled as guest code on top of a set of basic abstractions: threads and processes, synchronization, and address spaces with shared memory. These abstractions need to be provided as primitives by the symbolic execution engine, while the rest of the model can be emulated as guest code.

For incomplete and unstable dynamic language semantics, this thesis introduces \emph{\chef}, a platform for obtaining symbolic execution engines for interpreted languages by reusing their interpreters as executable specifications.  In \chef, the target program is bundled with the interpreter, running in a low-level (e.g., x86) symbolic execution engine, such that the aggregate system acts as a high-level execution engine for the program.
%
%% Chef automatically maps the low-level interpreter paths to high-level program paths by segmenting each low-level path into distinct high-level instructions.
%
To circumvent the complexity of symbolically executing the entire interpreter, this thesis introduces Class-uniform Path Analysis (CUPA), a heuristic for prioritizing paths that works by grouping paths into equivalence classes according to a coverage goal.

\noindent \textbf{Keywords:} Symbolic execution, program environments, systems software, interpreted languages.


\chapter*{Acknowledgments}

---

\tableofcontents
\listoffigures
\listoftables

\chapter{Introduction}
\label{ch:introduction}
\input{introduction}


\chapter{Related Work}
\label{ch:relatedwork}
\input{relatedwork}


\chapter{Cloud9: Symbolic Models for Stable Operating System Interfaces}
\chaptermark{Cloud9}
\label{ch:cloud9}
\input{cloud9}

\chapter{Chef: Using Interpreters as Specifications for Fast-changing Languages}
\chaptermark{Chef}
\label{ch:chef}
\input{chef}

\chapter{Evaluation}
\label{ch:evaluation}
\input{evaluation}

\chapter{Towards a Cloud Testing Service for PaaS}
\label{ch:paas}
\input{paas}

\chapter{Conclusion}
\label{ch:conclusion}

This thesis addressed two instances of the environment problem, which collectively cover a wide range of real-world software: (1) system software interacting with the operating system, and (2) high-level programs written in dynamic languages, such as Python, Ruby, or JavaScript.  The two instances exhibit opposite characteristics: while the operating system interfaces are typically stable and well-documented (e.g., POSIX), the specifications of dynamic languages are incomplete and unstable.

To address the environment problem for stable operating system interfaces, this thesis introduced \emph{\cnine}, a symbolic execution platform that provides an accurate and efficient model of the POSIX interface, as used by systems such as system utilities, web servers, or distributed systems.
%
\cnine relies on the insight that, for the purpose of testing, the operating system interface can be modeled as guest code on top of a set of basic abstractions: threads and processes, synchronization, and address spaces with shared memory. These abstractions need to be provided as primitives by the symbolic execution engine, while the rest of the model can be emulated as guest code.

For incomplete and unstable dynamic language semantics, this thesis introduced \emph{\chef}, a platform for obtaining symbolic execution engines for interpreted languages by reusing their interpreters as executable specifications.  In \chef, the target program is bundled with the interpreter, running in a low-level (e.g., x86) symbolic execution engine, such that the aggregate system acts as a high-level execution engine for the program.
%
%% Chef automatically maps the low-level interpreter paths to high-level program paths by segmenting each low-level path into distinct high-level instructions.
%
To circumvent the complexity of symbolically executing the entire interpreter, this thesis introduced Class-uniform Path Analysis (CUPA), a heuristic for prioritizing paths that works by grouping paths into equivalence classes according to a coverage goal.

\bibliographystyle{plain}
\bibliography{header-standard,biblio}

\end{document}


%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
