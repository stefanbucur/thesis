\iffalse % CHANGE TO iffalse FOR RELEASE
\documentclass[letterpaper,10pt,oneside]{book}
\usepackage[compact]{titlesec}   % Reduce the space between titles and text
\titleclass{\chapter}{straight}
\titleformat{\chapter}[display]
  {\normalfont\huge\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titlespacing*{\chapter} {0pt}{50pt}{40pt}
\else
\documentclass[letterpaper,12pt]{book}
\usepackage{setspace}
\onehalfspacing
\fi


\usepackage{geo}
\usletter

\usepackage{times}                 % Times New font
\usepackage{pifont}                % Ding symbols (for Cloud9)
\usepackage{wasysym}               % For the bullets in the interpreter comparison (Chef)
\usepackage{multirow}              % Cells spanning rows in tables
\usepackage{xspace}
\usepackage[labelfont=bf]{caption} % Bold caption labels
\usepackage{wrapfig}               % Side figures without caption




%% Global definitions
\newcommand{\thesistitle}{Improving Scalability of Symbolic Execution for Software with Complex Environment Interfaces}

\newcommand{\codebit}[1]{\textsf{\footnotesize #1}}

%% Cloud9 definitions
\newcommand{\cnine}{Cloud9\xspace}
\newcommand{\cninesuffix}{cloud9}

%% Chef definitions

\newcommand{\chef}{\textsc{Chef}\xspace}

\newcommand{\cupa}{{\small CUPA}\xspace}
\newcommand{\hlpc}{{\small HLPC}\xspace}
\newcommand{\hlpcs}{{\small HLPC}s\xspace}

\newcommand{\nicese}{NICE\xspace}
\newcommand{\cutiepy}{CutiePy\xspace}
\newcommand{\commuterse}{Commuter\xspace}



%% PDF SUPPORT
%% -----------

\usepackage[hidelinks]{hyperref} % Add cross references inside the PDF
\usepackage[all]{hypcap} % Fix the jump position when clicking figure references

\hypersetup{
  pdftitle={\thesistitle},
  pdfauthor={Stefan Bucur}
}



\begin{document}

\date{}
\title{\thesistitle}
\author{Stefan Bucur \\ EPFL, Switzerland}

\maketitle

\chapter*{Abstract (German)}

To be determined.

\chapter*{Abstract}

Software testing is laborious, time-consuming, and prone to human error.  Symbolic execution is a promising technique for automating test case generation.  However, its scalability to real-world software is limited by the \emph{environment problem}, i.e., the reliance of the target program on external functionality provided through complex interfaces, which the symbolic execution engine ought to support.
%
The environment problem is challenging to attack systematically, as its manifestations depend on the nature of the environment interface and its implementation.

This thesis addresses two instances of the environment problem, which collectively cover a wide range of real-world software: (1) system software interacting with the operating system, and (2) high-level programs written in dynamic languages, such as Python, Ruby, or JavaScript.  The two instances exhibit opposite characteristics: while the operating system interfaces are typically stable and well-documented (e.g., POSIX), the specifications of dynamic languages are incomplete and unstable.

To address the environment problem for stable operating system interfaces, this thesis introduces Cloud9, a symbolic execution platform that provides an accurate and efficient model of the POSIX interface, as used by systems such as system utilities, web servers, or distributed systems.
%
Cloud9 relies on the insight that, for the purpose of testing, the operating system interface can be modeled as guest code on top of a set of basic abstractions: threads and processes, synchronization, and address spaces with shared memory. These abstractions need to be provided as primitives by the symbolic execution engine, while the rest of the model can be emulated as guest code.

For incomplete and unstable dynamic language semantics, this thesis introduces Chef, a platform for obtaining symbolic execution engines for interpreted languages by reusing their interpreters as executable specifications.  In Chef, the target program is bundled with the interpreter, running in a low-level (e.g., x86) symbolic execution engine, such that the aggregate system acts as a high-level execution engine for the program.
%
%% Chef automatically maps the low-level interpreter paths to high-level program paths by segmenting each low-level path into distinct high-level instructions.
%
To circumvent the complexity of symbolically executing the entire interpreter, this thesis introduces Class-uniform Path Analysis (CUPA), a heuristic for prioritizing paths that works by grouping paths into equivalence classes according to a coverage goal.

\noindent \textbf{Keywords:} Symbolic execution, program environments, systems software, interpreted languages.


\chapter*{Acknowledgments}

TBD

\tableofcontents
\listoffigures
\listoftables

\chapter{Introduction}
\label{ch:introduction}
\input{introduction}


\chapter{Related Work}
\label{ch:relatedwork}
\input{relatedwork}


\chapter{Symbolic Abstractions for the Operating System Interface}
\chaptermark{Symbolic Abstractions for the OS Interface}
\label{ch:cloud9}
\input{cloud9}

\chapter{Using Language Interpreters as Executable Specifications}
\chaptermark{Interpreters as Executable Specifications}
\label{ch:chef}
\input{chef}

\chapter{Class-Uniform Path Analysis}
\label{ch:cupa}
\input{cupa}


\chapter{Parallel Symbolic Execution}
\label{ch:parsymbex}
\input{parsymbex}


\chapter{Evaluation}
\label{ch:evaluation}
\input{evaluation}

\chapter{Towards a Cloud Testing Service for PaaS}
\label{ch:paas}
\input{paas}


\chapter{Conclusion}
\label{ch:conclusion}

To be determined.

\bibliographystyle{plain}
\bibliography{header-standard,biblio}

\end{document}


%%% Local Variables: 
%%% mode: latex
%%% eval: (visual-line-mode)
%%% fill-column: 1000000
%%% TeX-master: "main"
%%% End:
